Katmanlar 

Data Access  : Veritabanýnda insert-update-delete sorgularýný çalýþtýracaðýmýz katman. Orm implementasyonlarý bu katmanda olur.Biz EF ve NHibernate ekledik. Abstract klasörü, diðer katmanlarýn veriye eriþim için kullanacaðý klasör.Böylece iþ katmaný EF yada NHibernate baðlý olmayacak.
Business  :Bu katmanda projeyi ilgilendiren iþ süreçlerini kodlarýz.Örneðin bir kiþinin ehliyete ihtiyacý var, biz bu kiþiye ehliyet verelim mi diye burada kodlarýz.
Core :Framework katmanýnda ; Loglama,Cacheleme,Transaction yönetimi,Performans yönetimi,Validasyon yönetimi,Rol bazlý güvenlik ve diðer araçlarýmýzý ,veritabaný Orm entegrasyonlarýný burada yaparýz.
Entities  :Burada normal nesnelerin yaný sýra joinli tablolarý tutarýz.
Mapping :Veritabaný ile nesnelerimizin baðlantýsýný kurar,iliþkilendirilmesini saðlar.Türkçe veritabaný kullanýrsak bunu yapmak zorundayýz.
Test  :Yaptýðýmýz iþlemlerin çalýþýp çalýþmadýðýný kontrol etmek için Unit Test kullanacaðýz.(Validation test için test framework kulladýk -Moq framework
	Data oluþturmamýzý saðlayacak.)

Teknolojiler : 

ILSpy	: .NET assembly decompiler , Businnes'deki Aspect'lerin kodlarýmýzda nasýl bir deðiþiklik yaptýðýna bakmak için kullanacaðýz.

Ninject  : DataAccess Katmanýna eriþmek için Businnes'in constructor blogunda IProductDal injection yaptýk Yani Product Manager'ý bize verilen bir IProductDal türündeki nesneye göre gerçekleþtirdik.Solid'e göre hiçbir katmanda diðer katmanýn instance’ýný çaðýramayýz( new leyemeyiz). Bu yüzden Business katmanda Dependency Injection konfigürasyonu yapacaðýz.Bunun için DI container’ý olan Ninject’i kullanacaðýz. Ýnstance Factory bize business Module döndürür,orada da neyi nasýl çözeceðini belittik.Buraya AutoMapper de eklersek onu da yönlendirmiþ olacaðýz.

Transaction  : Arka arkaya 3 iþlem yaptýk diyelim, ilk ikisi baþarýlý sonuncusu baþarýsýz oldu.Böyle bir durumda karar vermemiz gerekiyor ,önceki iþlemleri geri mi alacaðýz yoksa böyle devam edeceðiz.Bunun için transaction oluþturulur.

Cache	: Framework katmanýna (Core) ekleyeceðiz. Bir data istenildiðinde cache’ye eklenecek. Bunun için birçok yöntem kullanýlabilir, biz Memory Cache kullanacaðýz( bundan sonra o datayý kullanan kullanýcýlar eðer cache'de varsa datayý çekebilecek).Output Caching’de, eðer bir data parametreleriyle beraber cachelenirse ,ayný parametrelerle ayný data çaðrýldýðýnda tekrardan veri çekmeyecek cache’deki data kullanýlacak(Output ve Data Caching). 
MemoryCache ,microsoft .net framework içinde default olarak gelen caching yapýsýdýr.Bu altyapý datayý uygulama sunucusunun belleðinde tutacak ve uygulama sunucusunun belleðindeki dataya göre tüketip iþlem yapabilecek.Uygulama sunucusu, tek ve bir ISS üzerinden yayýn yapýyorsak memory cache performanslý olarak iþimizi görecektir. MemCache, RedisCache vs de kullanýlabilir.(Load Balancing,farklý uygulama sunucularý kullanýyoruz veya cache'i ayrý sunucuda tutmak istediðimizde kullanabileceðimiz yapýdýr.)
Log  : Framework katmanýnda konfigürasyonunu Log4Net ile yaptýk. Product Manager'daki Update metodunu loglamak istiyoruz bunun için kim hangi metodu,hangi parametrelerle çalýþtýrdý bilgisini tutmamýz gerekir.Dolayýsýyla log'u tutacak datayý yönetebileceðimiz bir nesneye ihtiyacýmýz var. Bu da LogParameter olacak. Loglama veritabanýna,metin dosyasýna,xml ,eventviewer,console vs yazýlabilir.Biz Json formatýnda tutacaðýz.Json formatýna bir nesneyi çevirebilmemiz için onu Serializable hale getirmeliyiz. Bunu Layouts/JsonLayout'da yapacaðýz(ayrýca bunun için classlara Serializable ekliyoruz).
Loglar ihtiyaca göre nerede çalýþacaðý deðiþir.Örneðin metodun baþýnda kim ne zaman hangi metodu çaðýrdý gibi birþey istersek o zaman OnEntry'le yapabiliriz.Metodun sonunda çaðýrabiliriz ve hata verdiðinde de.Log4Net için config dosyasý oluþturmalýyýz,bunu MVC Web UI içine oluþturup,web config içinde bunu kullanacaðýmýzý belirttik.
Bütün Manager'lar için performans ,loglama veya exception yapmak istersek, Assembly seviyesinde ekleme yapmamýz gerek (Bu class business'da properties altýnda).

Performans Yönetimi : Yazýlým tarafýndaki yavaþlýklarý tespit etmek adýna uygulamada herþey mi yavaþ çalýþýyor yoksa belli baþlý metotlar mý yavaþ çalýþýyor,bunu tespit etmemiz gerekiyor.Bunun için performansý takip edebilmeliyiz.Metotlarýn baþýna ve sonuna bir kronometre koyduk, bizim verdiðimiz metrikten daha yüksekse o zaman uyarý vermesini saðladýk , bu yapýyý Performance Aspect class’ý ile yapacaðýz.

Rol Bazlý Kullanýcý Yönetimi : Postsharp kullanýp, Asp.Net Mvc'de de Identity yapýsýný da kullanarak Claim bazlý Auth yapacaðýz.Ýlk önce veritabanýnda User,User Roles ve Roles tablolarý oluþturduk(tablolarýn iliþkilerinin belirtilmemesi halinde veri kaçaðý oluþur,koyulmasý gerekir).Bir rolun olup olmadýðýný Aspect oluþturup kontrol edeceðiz. Örneðin GetAll metodunu sadece belli role sahip kiþilerin görmesini istiyoruz.Bunun için metot baþýnda Secured Operation kullandýk.Identity için kendi configurasyonumuzu, Cross Cutting Concern’de , Security altýna, Identity nesnesi tanýmlayarak yapýyoruz.(Form Authentication yöntemi, kullanýcý bilgilerinin veri tabanýnda tutulduðu ve sorgu ile alýndýðý sistemlerdir.) (Session'da rolleri tutamayýz.) Kendi Authentication Helper'ýmýzý yazdýk(aslýnda Form Auth kullanýp ezdik).Web klasörü ,web arayüzleri için(client olarak web) kullanýlacak bir durum olduðundan buraya ekledik.Authentication Helper kullanýcý bilgilerini alýr þifreler ve cookie’ye basar.Cookie’yi okuyup kiþinin kim olduðu vs bilgilerini almak için Authentication Helper'ýn Create Auth Cookie metodu ile oluþturulan Cookie'nin ,uygulama boyunca kullanýlabilecek bir nesneye (Identity’ye),çevrilmesi gerekiyor ki kontrollerimizi  yapabilelim. FormAuthentication ticket’ýný bir Identity'e çevirmek için Core katmanýna Web klasörüne Security Utilities class oluþturduk.

Web Api Katmaný : Api'lerimizi yazdýðýmýz katman,api'lerin dýþýnda kod yazmamalýyýz. Ýþlemleri business üzerinden yürütmeliyiz( Arayüzün yerini api alýr).Web Api'de kiþi direkt controller’a istekte bulunuyor, bir modal-view-controller olmuyor, dolayýsýyla security aspect buradan geçmiyor. Bunun için, bir AuthHandler yazýp ,biri bize istekte bulunduðu zaman mesajý yakalamak ve bunun sonucunda kiþiyi (eðer bize kullanýcý adý ve þifre göndermiþse) authenticate olmasýný saðlayacaðýz. MessageHandler'ý istek kontrolü için yazdýk.WepApi projesinde App_Start, WebApiConfig sýnýfýnýn içine konfigürasyonu yazýyoruz.Authentication bilgilerini veritabanýndan almak için IUserService'i AuthHandler'a enjekte ediyoruz,bunu InstanceFactory ile yaptýk.

AutoMapper    : Dependency Injection kullanarak verdik.Serileþtirmeyi Business'da AutoMapper ile yaptýk.
WCF  : Servis odaklý bir mimaride (SOA) ,client server mimarileri baz alýnýr.Ýki pc olur biri asp.net diðeri wcf-service'i çalýþtýrýr.Asp.net tamamen servis'ten desteklenir(dll'den businnes'e gitmeyip service üzerinden çalýþýr). Tüm mimariyi servis odaklý mý çalýþmamýz lazým yoksa bazý servisleri mi açmak istiyoruz,bunlarýn yaklaþýmý birbirinden
farklýdýr.Bizim bir asp.net projemiz var ,service'ler baþka bir server'dan bize hizmet edecek,bu þekilde kullandýk. IProductService'in sevis olabilmesi için ServiceContract ve OperationContract özellikleri belirtilmelidir.Bunlarý belirtmek alternatif olarak yerine Wcf katmanýnda App_Code klasörü altýna ServiceContracts interface IProductDetailService 
eklenebilir.Yada business katmanýna ServiceContract altýna yapýlýp ProductDetailService Wcf'de kullanýlabilir.Service.svc dosyasýný ProductService.svc diye deðiþtirdik.Bu bizim yayýn dosyamýz.( Note : service.svc dosyasý açýkken çalýþtýrýrsak Acf test client editor gelir.) WebApi'de yada Mvc'de yaptýðýmýz gibi connectionstring ekledik. Mvc tarafýnda Wcf servisini çaðýrdýk(Normalde Wcf projesini çaðýrmanýn en basit yolu,Mvc katmanýna týklayýp Add>Service Reference ile Proxy oluþturup eklenir.Bizimki client-server mimarisi olduðu için baþka yöntem kullanacaðýz). Biz ChannelFactory ile runtime'da bir proxy oluþturup,onun üzerinden ilerleyeceðiz.Wcf Proxy ile Core katmanýnda proxy üreteceðiz, bunu Mvc'de çaðýracaðýz.Mvc katmanýnda web.config dosyasýna key olarak ekliyoruz. Ayrýca ChannelFactory'i üretecek BusinnesModule yerine ServiceModule yazacaðýz.Ve bunu  Mvc'de çalýþtýrmak için global.asax dosyasýnda factory kýsmýnda belirttik.

Angular   :  Mvc projesinin üstüne angular implemente edeceðiz.Bunun için öncelikle node kuracaðýz.TsScripts ,angular kodumuz için.Script, javascript kodumuz için.TypeScript kodunu JavaScript'e Gulp ile çevireceðiz.Package.json dosyasýný Angular projesine ekliyoruz.Buraya gulp paketlerini de eklemeliyiz. Gulp, yazdýðýmýz scriptlerin bir yerden bir yere taþýnmasýný ,deðiþiklik olduðu zaman build edilip atýlmasýný saðlayacak.Tsconfig.json , typescript konfigürasyonlarýný içerir.Buraya outDir eklenir.

Kullanýlan Paketler : 
--DevFramework.Core => Entity Framework 6.1.3,NHibernate 5.3.13,Fluent Validation 11.2.2,PostSharp 4.2.17,Log4Net 2.21.0,AutoMapper.6.1.1
--DevFramework.DataAccess => Entityframework 6.1.3 ,NHibernate 5.3.13,FluentNHibernate 3.1.0
--DevFramework.DataAccess.Test => Entity Framework 6.1.3 
--DevFramework.Businnes => Fluent Validation 11.2.2 ,PostSharp 4.2.17,Ninject 3.3.6,AutoMapper.6.1.1
--DevFramework.Businnes.Test =>PostSharp 4.2.17,MOQ 4.18.2 ,Fluent Validation 11.2.2 
--DevFramework.MvcWebUI =>Entity Framework 6.1.3, PostSharp 4.2.17
--DevFramework.WebApi => WebApiContrib.IoC.Ninject 0.9.3 ,Ninject 3.3.6(ayný versiyona çekmelisin),Ninject.MVC5.3.3.0,Ninject.Web.Common.3.3.2,
 Ninject.Web.Common 3.3.2,Entity Framework 6.1.3 
--DevFramework.WcfService => EntityFramework.6.1.3
--Pc için => PostSharp 4.2.17 


Katmanlar       :
DevFramework.Core Katmaný 

--IEntityRepository : where T : class ,referans tip olmalý
					-new() newlenebilir olmalý
					-IEntity ,sadece entity almasýný saðlýyoruz.
					-Liste döndürecek GetList'de Linq Expression kullandýk, çünkü datanýn tümü yada where koþulu ile belirtilmiþ kýsmýný getirmek istiyoruz.Bu baðlamda bir metot delegesi göndereceðiz , func ile .filter hem boþ gönderilebilir(yani herhangi bir filtre 
göndermeyebilir,o zaman tümünü getirecek. ama filtre gönderirse datanýn filtrelenmiþ versiyonunu db den getirecek)
					-Get ile tek nesne döndürebiliriz,burada da filtre yolladýk
					-Add ve Update,datanýn eklenmiþ hali ile döndüreceðiz.
					-Delete de primary key ile silinmesini saðlayacaðýz

--IQueryableRepository : Listlerle çalýþtýðýmýz zaman context'i açýp kapatýrýz.Queryable operasyonlarýnýn, business tarafýnda çalýþtýrýlabilmesi 
					(Context kapanmadan) için de bir repository yazacaðýz.(Not: IQueryable , IEnumerable dan hýzlýdýr ve serverda sorgu yapar.)
					-Table operasyonunda readonly yapýyoruz,Bir context'e attach olacaðýz ona baðlý olarak sorgu yapacaðýz.
--EFEntityRepositoryBase : Burada iki nesneye ihtiyacýmýz olacak; TEntity:veritabaný nesnesi,TContext:orm implementasyonu almýþ nesne ,hangi contexti
					gönderirsek onu alacak.(Basitçe hangi entity için iþlem yapacaðýný söyleceycek.)
--EFQueryableRepositoryBase : 
					-Table kýsmýnda  bir tabloya attach	olup o tablo üzerinden hangi nesneyi verirsek query çalýþtýrmamýzý saðlayacak
					-Context'e ihtiyacýmýz var, inject ediyoruz,böylelikle bu katmanýn herhangi bir baðlýlýðý olmayacak.
					-Buradaki tablo DbSet'e karþýlýk geliyor, o yüzden önceden gönderilen entity'e göre abone olacak
--NHibernateHelper : burada nhibernate context karþýlýðý session yapýsýný kullanýr.
--ValidatorTool    : Gönderdiðimiz validator aracýna göre örneðin product,bunlara göre iþlem yapacak.Manager'da çaðýrýyoruz.
--FluentValidationAspect : PostSharp kullanmak için OnMethodBoundaryAspect implemente ettik.OnEntry-metodun giriþinde ile metoda girdiðinde 
					doðrulama yapmak için kullanýlýr.Yani FluentValidationAspect'i kullanan kimse metodun giriþinde bu metod devreye girecek.
--ICacheManager		: Hangi data hangi parametrelerle çaðýrýlmýþsa ona göre cache oluþturmamýz gerekiyor, dolayýsýyla her cache datasýna isim 
					vermemiz gerekiyor.Ýsim verme iþlemini Unique Key oluþturarak vereceðiz.
--LogParameter      : Burada metot parametresinin ismini ,deðerini ve tipini tutuyoruz.
--LogDetail			:Ýhtiyaç duyduðumuz metodun bilgileri tutuyoruz.
--LoggerService		:Farklý ortamlarda farklý loglama tekniklerini kullanmak için kullanacaðýz.Örneðin çalýþma ortamýnda debuglarý kaydedebiliriz.


					
DevFramework.Business Katmaný 	

--Cross cutting concern (Kesiþen ilgililer): Validation ,cache ,authorization ,transaction yönetimi,performans yönetimi gibi iþlemleri iþ 
                    katmanýnda kullanýrýz.Bu iþlemler business de ortak olarak gerçekleþtiriliyor.Bunlarý ayýrmak için Aspect Oriented kullanacaðýz.
					AO ilgililerin ayrýlmasý prensibine dayanýr.AO kullanmak için postSharp yükleyip kullanacaðýz.

--Business katmanda IProductService ve ProductManager oluþturduk.IPService'e birkaç metot ekledik ve core katmanýndaki metotlarla devam ettirdik.
					Burada validasyon iþlemini yapacaðýz.Validasyon bir nesnenin format olarak uyumluluðu anlamýna gelir.
					DataAnatotation ile yapýlan validasyonlar Solid'e aykýrý oluyor.Entity'e koyulan DA yanlýþ katmanda yazýlmýþ oluyor ve bir 
					class içinde baþka iþlemler de yapmýþ oluyoruz.
--ProductManager   : Burada validasyonu Aspect oriented ile kullanacaðýz. Add metodunda geçen product'ýn,db'ye eklenirken validation kuralýna 
                    uyup uymadýðýna bakacaðýz.Fakat single responsibility den dolayý Validator Tool'u kullanmayýp, bunu Aspect oriented
					ile yapýyoruz.
					FluentValidate'i kullanabilmek için PostSharp-lisanslama için- yükledik.Ve postharp dll yükledik.



DevFramework.Business.Test Katmaný
					Burada diðer katmanlarý test ederken kullanmamamýz gerektiði için,buna yönelik iþlem yapacaðýz.
--ProductManagerTests : Burada product manager'ýn validationunu test edeceðiz.ProductManager , productDal'ý baþka katmandan alýr.
					 Dolayýsýyla MOQ framework bize IProductDal için bir concrete oluþturacak.Database'e gitmemiþ olacaðýz.DataAccess,Core,Entities
					 ve Business'e referans veriyoruz.


DevFramework.MvcWebUI Katmaný 

--log4net.Config	:Yaptýðýmýz loglarla ilgili config dosyasýna ihtiyacýmýz var.Bu config dosyasýný kullandýðýmýzý web config'e yazýyoruz.
					Loglarý yazabilmek için db'de Logs tablosu oluþturduk.



NOT: Arayüzde hiçbir zaman Product'ýn deðerleri doðru mu gibi kontolleri yapmamalýyýz.Baþka arayüze geçince problem olur ,businnesde yapýlmalý.
	Mvc'de modelStateIsValid ters kalýyor.(Clientside validation yapýlabilir.)
	
	
