DataAccess      :Veri eriþim katmaný ,veritabanýnda insert-update-delete sorgularýný çalýþtýracaðýmýz katman. Orm implementasyonlarý bu katmanda.EF ile baþlayýp,NHiber
				nate ekleyeceðiz.Abstract ile diðer katmalarýn veriye eriþim için kullancaðýmýz klasör.Böylece iþ katmaný EF yada NH'e baðlý olmayacak.
Business        : Projeyi ilgilendiren iþ süreçlerini kodlarýz.Örneðin bir kiþinin ehliyete ihtiyacý var biz bu kiþiye ehliyet verelim
			mi diye burada kodlarýz.Arayüz ile veritabaný iletiþimini saðladýk.
Core            : Loglama,Cacheleme,Transaction yönetimi,Performans yönetimi,Validasyon yönetimi,Rol bazlý güvenlik ve diðer araçlarýmýzý ,veritabaný
			Orm entegrasyonlarýný burada yaptýk
Entities        : ComplexTypes, iki üç tablonun joini sonucu oluþan nesne 
Mapping         : Veritabaný ile nesnelerimizin baðlantýsýný kurar,iliþkilendirilmesini saðlar.Türkçe veritabaný kullanýyorsak bunu yapmak zorundayýz
Test            :Yaptýðýmýz iþlemlerin çalýþýp çalýþmadýðýný kontrol etmek için kullanacaðýz.Validation test için test framework kulladýk -Moq
				Data oluþturmamýzý saðlayacak.
				Bir katmaný test ederken diðer katmanlarla kesinlikle iletiþim kurmamalýyýz,iletiþim kurarsak entegrasyon testi olur.Sadece o katmaný
				test etmeliyiz.
ILSpy			:ILSpy is the open-source .NET assembly browser and decompiler,Businnes'deki Aspect'lerin kodlarýmýzda nasýl bir deðiþiklik
				yaptýðýna bakmak için kullanacaðýz.

Ninject        :DataAccess Layer'a eriþmek için Businnes'in constructor blogunda IProductDal injection'u yaptýk
				Yani Product Manager'ý bize verilen bir IProductDal türündeki nesneye göre gerçekleþtirdik.ProductManager'da DAL ile çalýþtýk 
				bu da constructor injection ile yaptýk.Solid'e göre hiçbir katmanda diðer katmaný new'leyemeyiz.(Ayný katman içindeki diðer
				nesneler için de geçerli) Bu yüzden Businnes katmanda Dependecy Injection configurasyonu yapacaðýz.Bunun için DI conteiner'ýný 
				kullanacaðýz.
Transaction     : Arka arkaya 3 iþlem yaptýk diyelim, ilk ikisi baþarýlý sonuncusu baþarýsýz oldu.Böyle bir durumda karar vermemiz gerekiyor ,önceki
				iþlemleri geri mi alacaðýz yoksa böyle devam edeceðiz.


Proje Detaylarý : 
			Proje generic kýsýtlara göre oluþturulmuþtur.Orm toollarýnda geçiþ daha kolay olacak.
			Yeni bir teknoloji kullanacaksak bunlarýn hepsini klasörleyerek kullandýk.
Kullanýlan Paketler : 
--DevFramework.Core => Entity Framework 6.1.3,NHibernate 5.3.13,Fluent Validation 11.2.2,PostSharp 4.2.17
--DevFramework.DataAccess => Entity Framework 6.1.3 ,NHibernate 5.3.13,FluentNHibernate 3.1.0
--DevFramework.DataAccess.Test => Entity Framework 6.1.3 
--DevFramework.Businnes => Fluent Validation 11.2.2 ,PostSharp 4.2.17,Ninject 3.3.6
--DevFramework.Businnes.Test =>PostSharp 4.2.17,MOQ 4.18.2 ,Fluent Validation 11.2.2 
--Pc için => PostSharp 4.2.17 

Katmanlar       :
DevFramework.Core Katmaný 


--IEntityRepository : where T : class ,referans tip olmalý
					-new() newlenebilir olmalý
					-IEntity ,sadece entity almasýný saðlýyoruz.
					-Liste döndürecek GetList'de Linq Expression kullandýk, çünkü datanýn tümü yada where koþulu ile belirtilmiþ kýsmýný getirmek 
					istiyoruz.Bu baðlamda bir metot delegesi göndereceðiz , func ile .filter hem boþ gönderilebilir(yani herhangi bir filtre 
					göndermeyebilir,o zaman tümünü getirecek. ama filtre gönderirse datanýn filtrelenmiþ versiyonunu db den getirecek)
					-Get ile tek nesne döndürebiliriz,burada da filtre yolladýk
					-Add ve Update,datanýn eklenmiþ hali ile döndüreceðiz.
					-Delete de primary key ile silinmesini saðlayacaðýz

--IQueryableRepository : Listlerle çalýþtýðýmýz zaman context'i açýp kapatýrýz.Queryable operasyonlarýnýn, businnes tarafýnda çalýþtýrýlabilmesi 
					(Context kapanmadan) için de bir repository yazacaðýz.(Not: IQueryable , IEnumerable dan hýzlýdýr ve serverda sorgu yapar.)
					-Table operasyonunda readonly yapýyoruz,Bir context'e attach olacaðýz ona baðlý olarak sorgu yapacaðýz.
--EFEntityRepositoryBase : Burada iki nesneye ihtiyacýmýz olacak; TEntity:veritabaný nesnesi,TContext:orm implementasyonu almýþ nesne ,hangi contexti
					gönderirsek onu alacak.(Basitçe hangi entity için iþlem yapacaðýný söyleceycek.)
--EFQueryableRepositoryBase : 
					-Table kýsmýnda  bir tabloya attach	olup o tablo üzerinden hangi nesneyi verirsek query çalýþtýrmamýzý saðlayacak
					-Context'e ihtiyacýmýz var, inject ediyoruz,böylelikle bu katmanýn herhangi bir baðlýlýðý olmayacak.
					-Buradaki tablo DbSet'e karþýlýk geliyor, o yüzden önceden gönderilen entity'e göre abone olacak
--NHinernateHelper : burada nhibernate context karþýlýðý session yapýsýný kullanýr.
--ValidatorTool    : Gönderdiðimiz validator aracýna göre örneðin product,bunlara göre iþlem yapacak.Manager'da çaðýrýyoruz.
--FluentValidationAspect : PostSharp kullanmak için OnMethodBoundaryAspect implemente ettik.OnEntry-metodun giriþinde ile metoda girdiðinde 
					doðrulama yapmak için kullanýlýr.Yani FluentValidationAspect'i kullanan kimse metodun giriþinde bu metod devreye girecek.



					
DevFramework.Businnes Katmaný 	

--Cross cutting concern (Kesiþen ilgililer): Validation ,cache ,authorization ,transaction yönetimi,performans yönetimi gibi iþlemleri iþ 
                    katmanýnda kullanýrýz.Bu iþlemler businnesde ortak olarak gerçekleþtiriliyor.Bunlarý ayýrmak için Aspect Oriented kullanacaðýz.
					AO ilgililerin ayrýlmasý prensibine dayanýr.AO kullanmak için postSharp yükleyip kullanacaðýz.

--Businnes katmanda IProductService ve ProductManager oluþturduk.IPService'e birkaç metot ekledik ve core katmanýndaki metotlarla devam ettirdik.
					Burada validasyon iþlemini yapacaðýz.Validasyon bir nesnenin format olarak uyumluluðu anlamýna gelir.
					DataAnatotation ile yapýlan validasyonlar Solid'e aykýrý oluyor.Entity'e koyulan DA yanlýþ katmanda yazýlmýþ oluyor ve bir 
					class içinde baþka iþlemler de yapmýþ oluyoruz.
--ProductManager   : Burada validasyonu Aspect orianted ile kullanacaðýz. Add metodunda geçen product'ýn,db'ye eklenirken validation kurallýna 
                    uyup uymadýðýna bakacaðýz.Fakat single responsibilty'den dolayý ValidatorTool'u kullanmayýp, bunu Aspect orianted
					ile yapýyoruz.
					FluentValidate'i kullanabilmek için PostSharp-lisanslama için- yükledik.Ve postharp dll yükledik.



DevFramework.Businnes.Test Katmaný
					Burada diðer katmanlarý test ederken kullanmamamýz gerektiði için,buna yönelik iþlem yapacaðýz.
--ProductManagerTests : Burada product manager'ýn validationunu test edeceðiz.ProductManager , productDal'ý baþka katmandan alýr.
					 Dolayýsýyla MOQ framework bize IProductDal için bir concrete oluþturacak.Database'e gitmemiþ olacaðýz.DataAcces,Core,Entites
					 ve Businnes'e referans veriyoruz.

NOT: Arayüzde hiçbir zaman Product'ýn deðerleri doðru mu gibi kontolleri yapmamalýyýz.Baþka arayüze geçince problem olur ,businnesde yapýlmalý.
	Mvc'de modelStateIsValid ters kalýyor.(Clientside validation yapýlabilir.)

	