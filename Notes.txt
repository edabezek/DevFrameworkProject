DataAccess      :Veri eriþim katmaný ,veritabanýnda insert-update-delete sorgularýný çalýþtýracaðýmýz katman. Orm implementasyonlarý bu katmanda.EF ile baþlayýp,NHiber
				nate ekleyeceðiz.Abstract ile diðer katmalarýn veriye eriþim için kullancaðýmýz klasör.Böylece iþ katmaný EF yada NH'e baðlý olmayacak.
Business        :Projeyi ilgilendiren iþ süreçlerini kodlarýz.Örneðin bir kiþinin ehliyete ihtiyacý var biz bu kiþiye ehliyet verelim
			mi diye burada kodlarýz.Arayüz ile veritabaný iletiþimini saðladýk.
Core            :Loglama,Cacheleme,Transaction yönetimi,Performans yönetimi,Validasyon yönetimi,Rol bazlý güvenlik ve diðer araçlarýmýzý ,veritabaný
			Orm entegrasyonlarýný burada yaptýk
Entities        :ComplexTypes, iki üç tablonun joini sonucu oluþan nesne 
Mapping         :Veritabaný ile nesnelerimizin baðlantýsýný kurar,iliþkilendirilmesini saðlar.Türkçe veritabaný kullanýyorsak bunu yapmak zorundayýz
Test            :Yaptýðýmýz iþlemlerin çalýþýp çalýþmadýðýný kontrol etmek için kullanacaðýz.Validation test için test framework kulladýk -Moq
				Data oluþturmamýzý saðlayacak.
				Bir katmaný test ederken diðer katmanlarla kesinlikle iletiþim kurmamalýyýz,iletiþim kurarsak entegrasyon testi olur.Sadece o katmaný
				test etmeliyiz.
ILSpy			:ILSpy is the open-source .NET assembly browser and decompiler,Businnes'deki Aspect'lerin kodlarýmýzda nasýl bir deðiþiklik
				yaptýðýna bakmak için kullanacaðýz.

Ninject        :DataAccess Layer'a eriþmek için Businnes'in constructor blogunda IProductDal injection'u yaptýk
				Yani Product Manager'ý bize verilen bir IProductDal türündeki nesneye göre gerçekleþtirdik.ProductManager'da DAL ile çalýþtýk 
				bu da constructor injection ile yaptýk.Solid'e göre hiçbir katmanda diðer katmaný new'leyemeyiz.(Ayný katman içindeki diðer
				nesneler için de geçerli) Bu yüzden Businnes katmanda Dependecy Injection configurasyonu yapacaðýz.Bunun için DI conteiner'ýný 
				kullanacaðýz.
Transaction     :Arka arkaya 3 iþlem yaptýk diyelim, ilk ikisi baþarýlý sonuncusu baþarýsýz oldu.Böyle bir durumda karar vermemiz gerekiyor ,önceki
				iþlemleri geri mi alacaðýz yoksa böyle devam edeceðiz.
Cache			:Framework katmanýna ekleyeceðiz.Amacýmýz bir data istenildiðinde cache'e eklenecek-bir çok yöntem kullanýlabilir biz Memory cache
				kullanacaðýz- bundan sonra o datayý kullanan kullancýlar eðer cache'de varsa datayý çekebilecek.
				Output Caching, eðer bir data parametreleriyle beraber cachelenirse ,ayný parametrelerle ayný data çaðýrýldýðýnda tekrardan cache
				yapýlsýn.
				MemoryCache ,microsoft .net framework içinde default olarak gelen caching altyapýsýný kullanacaðýz.Bu altyapý datayý uygulama 
				sunucusunun belleðinde tutacak ve uygulama sunucusunun belleðindeki dataya göre tüketip iþlem yapabilecek.Uygulama sunucusu tek ve
				bir ISS üzerinden yayýn yapýyorsak memory cache performanslý olarak iþimizi görecektir.
				MemCache,RedisCache vs de kullanýlabilir.(LodBalancing,farklý uygulama sunucularý kullanýyoruz veya cache'i ayrý sunucuda tutmak
				istediðimizde kullanabiliriz.)
Log				:Framework katmanýnda yapacaðýz,Log4Net kullanacaðýz.Product Manager'daki Update matodunu loglamak istiyoruz bunun için kim hangi
				metodu,hangi parametrelerle çalýþtýrdý bilgisini tutmamýz gerekir.Dolayýsýyla log'u tutacak datayý yönetebileceðimiz bir nesneye
				ihtiyacýmýz var.Bu da LogParameter.
				Loglama veritabanýna,metin dosyasýna,xml ,eventviewer,console yazýlabilir.Biz Json formatýnda tutacaðýz.Json formatýna bir nesneyi
				çevirebilmemiz için onu Serializable hale getirmeliyiz.Bunu Layouts/JsonLayout'da yapacaðýz.
				Biz logger'ý ne zaman çaðýrýrýz? Loglar ihtiyaca göre nerede çalýþacaðý deðiþir.Örneðin metodun baþýnda kim ne zaman hangi metodu 
				çaðýrdý gibi birþey istersek o zaman OnEntry'le yapabiliriz.Metodun sonunda çaðýrabiliriz ve hata verdiðinde.
				Log4Net için config dosyasý oluþturmalýyýz,MVCWebUI içine oluþturup,web config içine bunu kullanacaðýmýzý belirttik.
				Bütün Manager'lar için loglama yapmak istersek, Assembly seviyesinde yapmamýz gerek.Businnes'da Properties altýna ekliyoruz.

Proje Detaylarý : 
			Proje generic kýsýtlara göre oluþturulmuþtur.Orm toollarýnda geçiþ daha kolay olacak.
			Yeni bir teknoloji kullanacaksak bunlarýn hepsini klasörleyerek kullandýk.
Kullanýlan Paketler : 
--DevFramework.Core => Entity Framework 6.1.3,NHibernate 5.3.13,Fluent Validation 11.2.2,PostSharp 4.2.17,Log4Net 2.21.0
--DevFramework.DataAccess => Entity Framework 6.1.3 ,NHibernate 5.3.13,FluentNHibernate 3.1.0
--DevFramework.DataAccess.Test => Entity Framework 6.1.3 
--DevFramework.Businnes => Fluent Validation 11.2.2 ,PostSharp 4.2.17,Ninject 3.3.6
--DevFramework.Businnes.Test =>PostSharp 4.2.17,MOQ 4.18.2 ,Fluent Validation 11.2.2 
--DevFramework.MvcWebUI =>Entity Framework 6.1.3, PostSharp 4.2.17
--Pc için => PostSharp 4.2.17 

Katmanlar       :
DevFramework.Core Katmaný 


--IEntityRepository : where T : class ,referans tip olmalý
					-new() newlenebilir olmalý
					-IEntity ,sadece entity almasýný saðlýyoruz.
					-Liste döndürecek GetList'de Linq Expression kullandýk, çünkü datanýn tümü yada where koþulu ile belirtilmiþ kýsmýný getirmek 
					istiyoruz.Bu baðlamda bir metot delegesi göndereceðiz , func ile .filter hem boþ gönderilebilir(yani herhangi bir filtre 
					göndermeyebilir,o zaman tümünü getirecek. ama filtre gönderirse datanýn filtrelenmiþ versiyonunu db den getirecek)
					-Get ile tek nesne döndürebiliriz,burada da filtre yolladýk
					-Add ve Update,datanýn eklenmiþ hali ile döndüreceðiz.
					-Delete de primary key ile silinmesini saðlayacaðýz

--IQueryableRepository : Listlerle çalýþtýðýmýz zaman context'i açýp kapatýrýz.Queryable operasyonlarýnýn, businnes tarafýnda çalýþtýrýlabilmesi 
					(Context kapanmadan) için de bir repository yazacaðýz.(Not: IQueryable , IEnumerable dan hýzlýdýr ve serverda sorgu yapar.)
					-Table operasyonunda readonly yapýyoruz,Bir context'e attach olacaðýz ona baðlý olarak sorgu yapacaðýz.
--EFEntityRepositoryBase : Burada iki nesneye ihtiyacýmýz olacak; TEntity:veritabaný nesnesi,TContext:orm implementasyonu almýþ nesne ,hangi contexti
					gönderirsek onu alacak.(Basitçe hangi entity için iþlem yapacaðýný söyleceycek.)
--EFQueryableRepositoryBase : 
					-Table kýsmýnda  bir tabloya attach	olup o tablo üzerinden hangi nesneyi verirsek query çalýþtýrmamýzý saðlayacak
					-Context'e ihtiyacýmýz var, inject ediyoruz,böylelikle bu katmanýn herhangi bir baðlýlýðý olmayacak.
					-Buradaki tablo DbSet'e karþýlýk geliyor, o yüzden önceden gönderilen entity'e göre abone olacak
--NHinernateHelper : burada nhibernate context karþýlýðý session yapýsýný kullanýr.
--ValidatorTool    : Gönderdiðimiz validator aracýna göre örneðin product,bunlara göre iþlem yapacak.Manager'da çaðýrýyoruz.
--FluentValidationAspect : PostSharp kullanmak için OnMethodBoundaryAspect implemente ettik.OnEntry-metodun giriþinde ile metoda girdiðinde 
					doðrulama yapmak için kullanýlýr.Yani FluentValidationAspect'i kullanan kimse metodun giriþinde bu metod devreye girecek.
--ICacheManager		: Hangi data hangi parametrelerle çaðýrýlmýþsa ona göre cache oluþturmamýz gerekiyor,dolayýsyla her cache datasýna isim 
					vermemiz gerekiyor.Ýsim verme iþlemini Uniq Key oluþturarak vereceðiz.
--LogParameter      : Burada metot parametresinin ismini ,deðerini ve tipini tutuyoruz.
--LogDetail			:Ýhtiyaç duyduðumuz metodun bilgileri tutuyoruz.
--LoggerService		:Farklý ortamlarda farklý loglama tekniklerini kullanmak için kullanacaðýz.Örnegin çalýþma ortamýnda debuglarý kaydedebiliriz.


					
DevFramework.Businnes Katmaný 	

--Cross cutting concern (Kesiþen ilgililer): Validation ,cache ,authorization ,transaction yönetimi,performans yönetimi gibi iþlemleri iþ 
                    katmanýnda kullanýrýz.Bu iþlemler businnesde ortak olarak gerçekleþtiriliyor.Bunlarý ayýrmak için Aspect Oriented kullanacaðýz.
					AO ilgililerin ayrýlmasý prensibine dayanýr.AO kullanmak için postSharp yükleyip kullanacaðýz.

--Businnes katmanda IProductService ve ProductManager oluþturduk.IPService'e birkaç metot ekledik ve core katmanýndaki metotlarla devam ettirdik.
					Burada validasyon iþlemini yapacaðýz.Validasyon bir nesnenin format olarak uyumluluðu anlamýna gelir.
					DataAnatotation ile yapýlan validasyonlar Solid'e aykýrý oluyor.Entity'e koyulan DA yanlýþ katmanda yazýlmýþ oluyor ve bir 
					class içinde baþka iþlemler de yapmýþ oluyoruz.
--ProductManager   : Burada validasyonu Aspect orianted ile kullanacaðýz. Add metodunda geçen product'ýn,db'ye eklenirken validation kurallýna 
                    uyup uymadýðýna bakacaðýz.Fakat single responsibilty'den dolayý ValidatorTool'u kullanmayýp, bunu Aspect orianted
					ile yapýyoruz.
					FluentValidate'i kullanabilmek için PostSharp-lisanslama için- yükledik.Ve postharp dll yükledik.



DevFramework.Businnes.Test Katmaný
					Burada diðer katmanlarý test ederken kullanmamamýz gerektiði için,buna yönelik iþlem yapacaðýz.
--ProductManagerTests : Burada product manager'ýn validationunu test edeceðiz.ProductManager , productDal'ý baþka katmandan alýr.
					 Dolayýsýyla MOQ framework bize IProductDal için bir concrete oluþturacak.Database'e gitmemiþ olacaðýz.DataAcces,Core,Entites
					 ve Businnes'e referans veriyoruz.


DevFramework.MvcWebUI Katmaný 

--log4net.Config	:Yaptýðýmýz loglarla ilgili config dosyasýna ihtihyacýmýz var.Bu config dosyasýný kullandýðýmýzý web config'e yazýyoruz.
					Loglarý yazabilmek için db'de Logs tablosu oluþturduk.



NOT: Arayüzde hiçbir zaman Product'ýn deðerleri doðru mu gibi kontolleri yapmamalýyýz.Baþka arayüze geçince problem olur ,businnesde yapýlmalý.
	Mvc'de modelStateIsValid ters kalýyor.(Clientside validation yapýlabilir.)
	
	